<!DOCTYPE html>
<html lang="fr_FR">

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta property="og:title" content="Functions JS">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://github.com/patobeur/colliders">
		<meta property="og:site_name" content="HTML Divs collisions tests">
		<meta charset="utf-8">
		<title>HTML Divs collisions tests</title>
	</head>

	<body>
		<div id="msg"></div>
		<script>
			const _createDiv = function (params) {
				let element = document.createElement(params.tag);
				if (params.attributes) {
					for (const key in params.attributes) {
						if (Object.hasOwnProperty.call(params.attributes, key))
							element[key] = params.attributes[key];
						if (params.style) {
							for (const key2 in params.style) {
								if (Object.hasOwnProperty.call(params.style, key2))
									element.style[key2] = params.style[key2];
							}
						}
					}
				}
				return element;
			}
			//-----------------------------------
			const COLLIDERS = {}
			const Rectangle = (
				function () {
					function Rectangle(htmlElement) {
						let angle = 0, transform = false

						this.htmlElement = htmlElement;
						this.width = htmlElement.clientWidth;
						this.height = htmlElement.clientHeight;

						if (typeof htmlElement.style.transform === 'string' && htmlElement.style.transform != '') {
							transform = parseFloat(htmlElement.style.transform.replace(/rotate\(|deg\)/g, ''));
							angle = transform ?? 0;
						}
						this.angle = angle
						this.setCorners(angle);
						console.log('Rectangle', this)
					}

					function sin(x) {
						return Math.sin(x / 180 * Math.PI);
					}

					function cos(x) {
						return Math.cos(x / 180 * Math.PI);
					}

					function getVectorLength(x, y, width, height) {
						var center = {
							x: x + width / 2,
							y: y + height / 2
						};
						//console.log('center: ',center);
						var vector = {
							x: (x - center.x),
							y: (y - center.y)
						};
						return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
					}

					function getRotatedTopLeftCornerOfRect(x, y, width, height, angle) {
						var center = {
							x: x + width / 2,
							y: y + height / 2
						};
						//console.log('center: ',center);
						var vector = {
							x: (x - center.x),
							y: (y - center.y)
						};
						//console.log('vector: ',vector);
						var rotationMatrix = [[cos(angle), -sin(angle)], [sin(angle), cos(angle)]];
						//console.log('rotationMatrix: ',rotationMatrix);
						var rotatedVector = {
							x: vector.x * rotationMatrix[0][0] + vector.y * rotationMatrix[0][1],
							y: vector.x * rotationMatrix[1][0] + vector.y * rotationMatrix[1][1]
						};
						//console.log('rotatedVector: ',rotatedVector);
						return {
							x: (center.x + rotatedVector.x),
							y: (center.y + rotatedVector.y)
						};
					}

					function getOffset(el) {
						var _x = 0;
						var _y = 0;
						while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
							_x += el.offsetLeft - el.scrollLeft;
							_y += el.offsetTop - el.scrollTop;
							el = el.offsetParent;
						}
						return {
							top: _y,
							left: _x
						};
					}

					function pointInPoly(verties, testx, testy) {
						var i,
							j,
							c = 0
						nvert = verties.length;
						for (i = 0, j = nvert - 1; i < nvert; j = i++) {
							if (((verties[i].y > testy) != (verties[j].y > testy)) && (testx < (verties[j].x - verties[i].x) * (testy - verties[i].y) / (verties[j].y - verties[i].y) + verties[i].x))
								c = !c;
						}
						return c;
					}

					function testCollision(rectangle) {
						var collision = false;
						this.getCorners().forEach(function (corner) {
							var isCollided = pointInPoly(rectangle.getCorners(), corner.x, corner.y);
							if (isCollided) collision = true;
						});
						return collision;
					}

					function checkRectangleCollision(rect, rect2) {
						if (testCollision.call(rect, rect2)) return true;
						else if (testCollision.call(rect2, rect)) return true;
						return false;
					}

					function getAngleForNextCorner(anc, vectorLength) {
						var alpha = Math.acos(anc / vectorLength) * (180 / Math.PI);
						return 180 - alpha * 2;
					}

					Rectangle.prototype.setCorners = function (angle) {
						this.originalPos = getOffset(this.htmlElement);
						this.leftTopCorner = getRotatedTopLeftCornerOfRect(this.originalPos.left, this.originalPos.top, this.width, this.height, angle);

						var vecLength = getVectorLength(this.originalPos.left, this.originalPos.top, this.width, this.height);
						//console.log('vecLength: ',vecLength);

						angle = angle + getAngleForNextCorner(this.width / 2, vecLength);
						//console.log('angle: ',angle);
						this.rightTopCorner = getRotatedTopLeftCornerOfRect(this.originalPos.left, this.originalPos.top, this.width, this.height, angle);

						angle = angle + getAngleForNextCorner(this.height / 2, vecLength);
						//console.log('angle: ',angle);
						this.rightBottomCorner = getRotatedTopLeftCornerOfRect(this.originalPos.left, this.originalPos.top, this.width, this.height, angle);

						angle = angle + getAngleForNextCorner(this.width / 2, vecLength);
						//console.log('angle: ',angle);
						this.leftBottomCorner = getRotatedTopLeftCornerOfRect(this.originalPos.left, this.originalPos.top, this.width, this.height, angle);

						// console.log(this);
					};

					Rectangle.prototype.getCorners = function () {
						return [this.leftTopCorner, this.rightTopCorner, this.rightBottomCorner, this.leftBottomCorner];
					};

					Rectangle.prototype.isCollided = function (rectangle) {
						return checkRectangleCollision(this, rectangle);
					};
					return Rectangle;
				}
			)();
			function checkcollisionRect(A, B) {
				A.setCorners(A.angle);
				B.setCorners(B.angle);
				if (A.isCollided(B)) return true;
				return false
			}

			var divs = {}
			var physicBodies = []
			//-----------------------------------
			var cont = _createDiv({
				tag: 'div',
				attributes: { className: 'map', textContent: '' },
				style: { position: 'absolute', top: '100px', left: '200px', backgroundColor: '#e0e0e0', width: '250px', height: '100px' }
			})
			var msgDiv = _createDiv({
				tag: 'div',
				attributes: { className: 'msg', textContent: 'ok' },
				style: { color: '#000000' }
			})
			divs['PLAYER'] = _createDiv({
				tag: 'div',
				attributes: { id: 'player', className: 'player', textContent: '' },
				style: { position: 'absolute', borderRadius: '50%', backgroundColor: '#FF0000', width: '32px', height: '32px', transform: 'rotate(28.9deg)', top: '140px', left: '250px' }
			})
			divs['wall_1'] = _createDiv({
				tag: 'div',
				attributes: { className: 'wall', textContent: 'W1' },
				style: { position: 'absolute', backgroundColor: '#00FF00', width: '250px', height: '75px', transform: 'rotate(16deg)', top: '60px', left: '180px' }
			})
			divs['wall_2'] = _createDiv({
				tag: 'div',
				attributes: { className: 'wall', textContent: 'W2' },
				style: { position: 'absolute', backgroundColor: '#0000FF', width: '60px', height: '275px', transform: 'rotate(16deg)', top: '160px', left: '280px' }
			})

			cont.appendChild(divs['wall_1'])
			cont.appendChild(divs['wall_2'])
			cont.appendChild(divs['PLAYER'])

			document.body.appendChild(cont)
			document.body.appendChild(msgDiv)


			var rectPlayer = new Rectangle(divs['PLAYER']);
			var rectB = new Rectangle(divs['wall_1']);
			var rectC = new Rectangle(divs['wall_2']);
			physicBodies.push(rectB)
			physicBodies.push(rectC)

			window.requestAnimFrame = function () {
				return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame;
			}();


			function draw() {
				rectPlayer.angle += 1.2;
				divs['PLAYER'].style.transform = 'rotate(' + rectPlayer.angle + 'deg)';
				let collisions = 0
				// rectB.angle += 5.5;
				// divs['wall_1'].style.transform = 'rotate(' + rectB.angle + 'deg)';

				physicBodies.forEach(element => {
					element.angle += 5.5
					element.htmlElement.style.transform = 'rotate(' + rectB.angle + 'deg)';
					if (checkcollisionRect(rectPlayer, element)) collisions++
				});

				if (collisions > 0) {
					msgDiv.textContent = collisions + ' collision' + (collisions > 1 ? 's' : '') + ' detected!';
				}
				else { if (msgDiv.textContent != '') { msgDiv.textContent = '' } }

				setTimeout(function () {
					window.requestAnimFrame(draw);
				}, 50);
			}
			window.requestAnimFrame(draw);
		</script>
	</body>

</html>
